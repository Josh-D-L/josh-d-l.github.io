<!DOCTYPE html>
<HTML>

<head>
	<link rel="canonical" href="https://josh-d-l.github.io/Math-Machines/Triangle-Calculator" />
	<style>
	.spoiler {
		background-color: #A0A0A0;
		display: inline;
		position: fixed;
		top: 20px;
		right: 25px;
	}
	canvas {
		margin-left: auto;
		margin-right: auto;
		display: block;
	}
	</style>
</head>

<BODY>
	<div style="display:none" id="Data Storage">

	</div>
	<H1 style="text-align:center" id="title">Triangle Calculator</H1>
	<p style="text-align:center">
		Currently testing, bugs may be present. Please report any that you find.
	</p>
	<button type="button" style="position: fixed; right: 25px; top: 0px" id="spoilerShow" onclick="toggleDisplay()">Settings</button>
	<br>
	<br>
	<div class="spoiler" onmouseout="hide()" id="spoiler">
		<input type="color" id="Background Color" onchange="backgroundColor()">
		Background Color
		<br>
		<input type="color" id="Text Color" onchange="textColor()">
		Text Color
		<br>
		<input type="color" id="Title Color" onchange="titleColor()">
		Title Color
		<br>
		<input type="number" id="Font Size" onchange="fontSize()" style="width: 45px" value="16" min="1" max="100">
		Font Size (px)
		<br>
		<input type="color" id="Line Color">
		Diagram Line Color
		<br>
		<input type="color" id="Diagram Background Color">
		Diagram Background Color
		<br>
		<input type="number" id="Height/Width" value="500" style="width: 45px" min="1">
		Diagram Height / Width (px)
		<br>
		<input type="number" id="Interval" value="3" style="width: 45px" onchange="update()" min="0.01">
		Update Interval (Seconds)
		<br>
		<input type="number" id="Rounding" value="2" style="width: 45px" min="0" max="50">
		Round to __ places
		<br>
		<button type="button" onclick="reset()">Reset Settings</button>
	</div>
	<canvas id="diagram" width="500" height="500" style="border:1px solid #000000;" title="Diagram">Your browswer does not support canvas.</canvas>
	<div style="position:absolute; top:100px">
		Points
		<input type="text" class="Point" style="width: 12px" title="A letter" value="A" onBlur="changeVariable();"></input>
		<input type="text" class="Point" style="width: 12px" title="A letter" value="B" onBlur="changeVariable1();"></input>
		<input type="text" class="Point" style="width: 12px" title="A letter" value="C" onBlur="changeVariable2();"></input>
		<br>
		&ang;<span class="VariableA">A</span>&nbsp;=&nbsp;<input type="text" class="Angle" style="width: 25px" title="Angle Measure"></input>°
		&ang;<span class="VariableB">B</span>&nbsp;=&nbsp;<input type="text" class="Angle" style="width: 25px" title="Angle Measure"></input>°
		&ang;<span class="VariableC">C</span>&nbsp;=&nbsp;<input type="text" class="Angle" style="width: 25px" title="Angle Measure"></input>°
		<br>
		<span class="VariableA">A</span><span class="VariableB">B</span>&nbsp;=&nbsp;<input type="text" class="Side" style="width: 25px" title="Side Length"></input>
		<span class="VariableB">B</span><span class="VariableC">C</span>&nbsp;=&nbsp;<input type="text" class="Side" style="width: 25px" title="Side Length"></input>
		<span class="VariableA">A</span><span class="VariableC">C</span>&nbsp;=&nbsp;<input type="text" class="Side" style="width: 25px" title="Side Length"></input>
		<br>
		<br>
		<div id="ABC">
			&ang;<span class="VariableA">A</span>&nbsp;=&nbsp;<span class="angA"></span>°
			<br>
			&ang;<span class="VariableB">B</span>&nbsp;=&nbsp;<span class="angB"></span>°
			<br>
			&ang;<span class="VariableC">C</span>&nbsp;=&nbsp;<span class="angC"></span>°
			<br>
			<span class="VariableA">A</span><span class="VariableB">B</span>&nbsp;=&nbsp;<span class="sideAB"></span>
			<br>
			<span class="VariableB">B</span><span class="VariableC">C</span>&nbsp;=&nbsp;<span class="sideBC"></span>
			<br>
			<span class="VariableA">A</span><span class="VariableC">C</span>&nbsp;=&nbsp;<span class="sideAC"></span>
		</div>
		<br>
		<span id="Error" style="color:#A00000;font-weight:bold;"></span>
		<br>
		<p>
			&ang;<span class="VariableB">B</span> must have the greatest measure.
		</p>
	</div>
	<script type="text/javascript">
		var host = "http://josh-d-l.github.io";
		if ((host == window.location.host) && (window.location.protocol != "https:")) {
			window.location.protocol = "https";
		}
		var timeoutIds = [];
		document.getElementsByClassName("spoiler")[0].style.display = "none";
		document.getElementById("Diagram Background Color").value = "#FFFFFF";
		document.getElementById("Background Color").value = "#FFFFFF";
		titleColor();
		update();
		var toggle = "on";
		function toggleDisplay() {
			if (toggle == "on") {
				document.getElementById("spoiler").style.display = "initial";
				toggle = "off";
			} else {
				document.getElementById("spoiler").style.display = "none";
				toggle = "on";
			}
		}
		var validNavigation = false;
		function endSession() {
			localStorage.setItem("Diagram Background Color", document.getElementById("Diagram Background Color").value);
			localStorage.setItem("Background Color", document.getElementById("Background Color").value);
			localStorage.setItem("Title Color", document.getElementById("Title Color").value);
			localStorage.setItem("Text Color", document.getElementById("Text Color").value);
			localStorage.setItem("Line Color", document.getElementById("Line Color").value);
			localStorage.setItem("Interval", document.getElementById("Interval").value);
			localStorage.setItem("Rounding", document.getElementById("Rounding").value);
			localStorage.setItem("Height/Width", document.getElementById("Height/Width").value);
		}
		window.onbeforeunload = function() {
			if (!validNavigation) {
				 endSession();
			}
		}
		window.onkeypress=function(e) {
			if (e.keyCode == 116){
				validNavigation = true;
			}
		};
		function hide() {
			var wait = setTimeout(function() {
				toggle = "on";
				document.getElementById("spoiler").style.display = "none";
			}, 3000);
			document.getElementById("spoiler").addEventListener("mouseover", function() {
				clearTimeout(wait);
			}, false);
		}
		function backgroundColor() {
			var color = document.getElementById("Background Color").value;
			document.body.style.backgroundColor = color;
		}
		function textColor() {
			var color = document.getElementById("Text Color").value;
			document.body.style.color = color;
		}
		function titleColor() {
			var color = document.getElementById("Title Color").value;
			document.getElementById("title").style.color = color;
		}
		function fontSize() {
			var size = document.getElementById("Font Size").value;
			document.body.style.fontSize = size + "px";
		}
		function settings() {
			if (localStorage.getItem("Diagram Background Color") != null) {
				document.getElementById("Diagram Background Color").value = localStorage.getItem("Diagram Background Color");
			}
			if (localStorage.getItem("Background Color") != null) {
				document.getElementById("Background Color").value = localStorage.getItem("Background Color");
			}
			if (localStorage.getItem("Height/Width") != null) {
				document.getElementById("Height/Width").value = localStorage.getItem("Height/Width");
			}
			if (localStorage.getItem("Font Size") != null) {
				document.getElementById("Font Size").value = localStorage.getItem("Font Size");
				document.body.style.fontSize = localStorage.getItem("Font Size") + "px";
			}
			document.getElementById("Title Color").value = localStorage.getItem("Title Color");
			document.getElementById("Text Color").value = localStorage.getItem("Text Color");
			document.getElementById("Line Color").value = localStorage.getItem("Line Color");
			if (localStorage.getItem("Interval") != null) {
				document.getElementById("Interval").value = localStorage.getItem("Interval");
			}
			if (localStorage.getItem("Rounding") != null) {
				document.getElementById("Rounding").value = localStorage.getItem("Rounding");
			}
			document.getElementById("title").style.color = localStorage.getItem("Title Color");
			document.body.style.color = localStorage.getItem("Text Color");
			document.body.style.backgroundColor = localStorage.getItem("Background Color");
		}
		settings();
		function reset() {
			document.getElementById("Diagram Background Color").value = "#FFFFFF";
			document.getElementById("Background Color").value = "#FFFFFF";
			document.getElementById("Title Color").value = "#000000";
			document.getElementById("Text Color").value = "#000000";
			document.getElementById("Line Color").value = "#000000";
			document.getElementById("Interval").value = "3";
			document.getElementById("Rounding").value = "2";
			document.getElementById("Height/Width").value = "500";
			document.getElementById("title").style.color = "#000000";
			document.getElementById("Font Size").value = "16";
			document.body.style.fontSize = 16 + "px";
			document.body.style.color = "#000000";
			document.body.style.backgroundColor = "#FFFFFF";
			update();
		}
		function toDegrees(num) {
			return num * 180 / Math.PI;
		}
		function toRadians(num) {
			return num * Math.PI / 180;
		}
		function factorial(num) {
			var multiplied = 1;
			for (var x = num; x > 1; x--) {
				multiplied = multiplied * x;
			}
			return multiplied;
		}
		function changeVariable() {
			for (var x = 0; x < document.getElementsByClassName("VariableA").length; x++) {
				var Variable = document.getElementsByClassName("Point")[0].value;
				document.getElementsByClassName("VariableA")[x].innerText = Variable;
			}
		}
		function changeVariable1() {
			for (var x = 0; x < document.getElementsByClassName("VariableB").length; x++) {
				var Variable = document.getElementsByClassName("Point")[1].value;
				document.getElementsByClassName("VariableB")[x].innerText = Variable;
			}
		}
		function changeVariable2() {
			for (var x = 0; x < document.getElementsByClassName("VariableC").length; x++) {
				var Variable = document.getElementsByClassName("Point")[2].value;
				document.getElementsByClassName("VariableC")[x].innerText = Variable;
			}
		}
		function scale(info) {
			if (info[1] > 90 || info[2] > 90 || info[0] > 90) {
				var s = (info[3] + info[4] + info[5]) / 2;
				var area = Math.sqrt(s * (s - info[3]) * (s - info[4]) * (s - info[5]));
				var height = 2 * area / info[4];
				var width = info[4] + Math.sqrt(Math.pow(info[3], 2) - Math.pow(height, 2));
				var diagram = document.getElementById("diagram");
				var scaling = (diagram.height - 40) / Math.max(height, width);
				return [scaling, Math.sqrt(Math.pow(info[3], 2) - Math.pow(height, 2)) * scaling, height * scaling, 0];
			} else if (info[1] == 90 || info[2] == 90 || info[0] == 90) {
				var height = info[3];
				var width = info[4];
				var diagram = document.getElementById("diagram");
				var scaling = (diagram.height - 40) / Math.max(height, width);
				return [scaling, 0, height * scaling, 0];
			} else {
				var s = (info[3] + info[4] + info[5]) / 2;
				var area = Math.sqrt(s * (s - info[3]) * (s - info[4]) * (s - info[5]));
				var height = 2 * area / info[4];
				var width = info[4];
				var diagram = document.getElementById("diagram");
				var scaling = (diagram.height - 40) / Math.max(height, width);
				return [scaling, 0, height * scaling, Math.sqrt(Math.pow(info[3], 2) - Math.pow(height, 2)) * scaling];
			}
		}
		function setAngleA(value) {
			document.getElementsByClassName("angA")[0].innerText = value;
		}
		function setAngleB(value) {
			document.getElementsByClassName("angB")[0].innerText = value;
		}
		function setAngleC(value) {
			document.getElementsByClassName("angC")[0].innerText = value;
		}
		function setSideAB(value) {
			document.getElementsByClassName("sideAB")[0].innerText = value;
		}
		function setSideBC(value) {
			document.getElementsByClassName("sideBC")[0].innerText = value;
		}
		function setSideAC(value) {
			document.getElementsByClassName("sideAC")[0].innerText = value;
		}
		function update() {
			var angleA = document.getElementsByClassName("Angle")[0].value;
			var angleB = document.getElementsByClassName("Angle")[1].value;
			var angleC = document.getElementsByClassName("Angle")[2].value;
			var sideAB = document.getElementsByClassName("Side")[0].value;
			var sideBC = document.getElementsByClassName("Side")[1].value;
			var sideAC = document.getElementsByClassName("Side")[2].value;
			var diagram = document.getElementById("diagram");
			var draw = diagram.getContext("2d");
			draw.clearRect(0, 0, diagram.width, diagram.height);
			diagram.width = document.getElementById("Height/Width").value;
			diagram.height = document.getElementById("Height/Width").value;
			var pointA = document.getElementsByClassName("Point")[0].value;
			var pointB = document.getElementsByClassName("Point")[1].value;
			var pointC = document.getElementsByClassName("Point")[2].value;
			setAngleA("");
			setAngleB("");
			setAngleC("");
			setSideAB("");
			setSideBC("");
			setSideAC("");
			document.getElementById("Error").innerText = "";
			var info = calculate();
			setAngleA(info[0]);
			setAngleB(info[1]);
			setAngleC(info[2]);
			setSideAB(info[3]);
			setSideBC(info[4]);
			setSideAC(info[5]);
			var y;
			for (var x = 0; x < info.length; x++) {
				if (info[x].toString().indexOf("√") > -1) {
					y = info[x].split("√");
					y[1] = Math.sqrt(y[1]);
					if (y[0] != "") {
						info[x] = y[0] * y[1];
					} else {
						info[x] = y[1];
					}
				}
				else {
					info[x] = Number(info[x]);
				}
			}
			var boolValue = true;
			for (var x = 0; x < info.length; x++) {
				if (Boolean(info[x]) == false) {
					boolValue = false;
				}
			}
			if (boolValue == true) {
				var height = diagram.height;
				var width = diagram.width;
				var scaleInfo = scale(info);
				var scaling = scaleInfo[0];
				var pointAcoords = [20 + scaleInfo[3], height - scaleInfo[2] - 20];
				var pointBcoords = [20 + scaleInfo[1], height - 20];
				var pointCcoords = [pointBcoords[0] + info[4] * scaling, height - 20];
				diagram.style.backgroundColor = document.getElementById("Diagram Background Color").value;
				draw.strokeStyle = document.getElementById("Line Color").value;
				draw.moveTo(pointAcoords[0], pointAcoords[1]);
				draw.lineTo(pointBcoords[0], pointBcoords[1]);
				draw.stroke();
				draw.moveTo(pointBcoords[0], pointBcoords[1]);
				draw.lineTo(pointCcoords[0], pointCcoords[1]);
				draw.stroke();
				draw.moveTo(pointAcoords[0], pointAcoords[1]);
				draw.lineTo(pointCcoords[0], pointCcoords[1]);
				draw.stroke();
				draw.font = document.getElementById("Font Size").value + "px Arial";
				draw.fillStyle= document.getElementById("Text Color").value;
				draw.fillText(pointA, pointAcoords[0] - 10, pointAcoords[1]);
				draw.fillText(pointB, pointBcoords[0] - 10, pointBcoords[1] + 10);
				draw.fillText(pointC, pointCcoords[0], pointCcoords[1] + 10);
				if (info[1] == 90) {
					draw.moveTo(pointBcoords[0], pointBcoords[1] - 10);
					draw.lineTo(pointBcoords[0] + 10, pointBcoords[1] - 10);
					draw.stroke();
					draw.moveTo(pointBcoords[0] + 10, pointBcoords[1] - 10);
					draw.lineTo(pointBcoords[0] + 10, pointBcoords[1]);
					draw.stroke();
				}
			}
			var interval = document.getElementById("Interval").value;
			if (isNaN(interval) == true) {
				interval = 3;
			} else if (interval <= 0) {
				interval = 3;
			}
			for (var i=0; i<timeoutIds.length; i++) {
  				clearTimeout(timeoutIds[i]);
			}
			timeoutIds.push(window.setTimeout(update, interval * 1000));
		}
		function calculate() {
			var angleA = document.getElementsByClassName("Angle")[0].value;
			var angleB = document.getElementsByClassName("Angle")[1].value;
			var angleC = document.getElementsByClassName("Angle")[2].value;
			var sideAB = document.getElementsByClassName("Side")[0].value;
			var sideBC = document.getElementsByClassName("Side")[1].value;
			var sideAC = document.getElementsByClassName("Side")[2].value;
			setAngleA(angleA);
			setAngleB(angleB);
			setAngleC(angleC);
			setSideAB(sideAB);
			setSideBC(sideBC);
			setSideAC(sideAC);
			var boolValues = [Boolean(angleA), Boolean(angleB), Boolean(angleC), Boolean(sideAB), Boolean(sideBC), Boolean(sideAC), angleB == 90];
			var simplifiedReturnInfo = [angleA,angleB,angleC,sideAB,sideBC,sideAC];
			var returnInfo = [angleA,angleB,angleC,sideAB,sideBC,sideAC];
			var y;
			for (var x = 0; x < returnInfo.length; x++) {
				if (simplifiedReturnInfo[x].toString().indexOf("√") > -1) {
					y = simplifiedReturnInfo[x].split("√");
					y[1] = Math.sqrt(y[1]);
					if (y[0] != "") {
						simplifiedReturnInfo[x] = y[0] * y[1];
					} else {
						simplifiedReturnInfo[x] = y[1];
					}
				}
				else {
					simplifiedReturnInfo[x] = Number(simplifiedReturnInfo[x]);
				}
			}
			switch (boolValues.join(",")) {
				// All info given
				case 'true,true,true,true,true,true,true':
					break;
				case 'true,true,true,true,true,true,false':
					break;
				// One angle missing
				case 'false,true,true,true,true,true,true':
					returnInfo[0] = 90 - returnInfo[2];
					break;
				case 'false,true,true,true,true,true,false':
					returnInfo[0] = 180 - returnInfo[1] - returnInfo[2];
					break;
				case 'true,false,true,true,true,true,false':
					returnInfo[1] = 180 - returnInfo[0] - returnInfo[2];
					break;
				case 'true,true,false,true,true,true,true':
					returnInfo[2] = 90 - returnInfo[0];
					break;
				case 'true,true,false,true,true,true,false':
					returnInfo[2] = 180 - returnInfo[0] - returnInfo[1];
					break;
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Other Triangles - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				// All angles missing (Law of Cosine - SSS)
				case 'false,false,false,true,true,true,false':
					var workingAngleA = Math.pow(simplifiedReturnInfo[5], 2) + Math.pow(simplifiedReturnInfo[3], 2) - Math.pow(simplifiedReturnInfo[4], 2);
					workingAngleA = workingAngleA / (2 * simplifiedReturnInfo[5] * simplifiedReturnInfo[3]);
					workingAngleA = toDegrees(Math.acos(workingAngleA));
					returnInfo[0] = Math.round((workingAngleA) * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value);
					var workingAngleC = Math.pow(simplifiedReturnInfo[4], 2) + Math.pow(simplifiedReturnInfo[5], 2) - Math.pow(simplifiedReturnInfo[3], 2);
					workingAngleC = workingAngleC / (2 * simplifiedReturnInfo[4] * simplifiedReturnInfo[5]);
					workingAngleC = toDegrees(Math.acos(workingAngleC));
					returnInfo[2] = Math.round((workingAngleC) * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value);
					returnInfo[1] = Math.round((180 - (workingAngleA + workingAngleC)) * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value);
					break;
				// Two angles missing (Law of Cosine - SSS)
				case 'true,false,false,true,true,true,false':
					var workingAngleC = Math.pow(simplifiedReturnInfo[4], 2) + Math.pow(simplifiedReturnInfo[5], 2) - Math.pow(simplifiedReturnInfo[3], 2);
					workingAngleC = workingAngleC / (2 * simplifiedReturnInfo[4] * simplifiedReturnInfo[5]);
					workingAngleC = toDegrees(Math.acos(workingAngleC));
					returnInfo[2] = Math.round((workingAngleC) * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value);
					returnInfo[1] = Math.round((180 - (Number(simplifiedReturnInfo[0]) + workingAngleC)) * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value);
					break;
				case 'false,true,false,true,true,true,false':
					var workingAngleC = Math.pow(simplifiedReturnInfo[4], 2) + Math.pow(simplifiedReturnInfo[5], 2) - Math.pow(simplifiedReturnInfo[3], 2);
					workingAngleC = workingAngleC / (2 * simplifiedReturnInfo[4] * simplifiedReturnInfo[5]);
					workingAngleC = toDegrees(Math.acos(workingAngleC));
					returnInfo[2] = Math.round((workingAngleC) * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value);
					returnInfo[0] = Math.round((180 - (simplifiedReturnInfo[1] + workingAngleC)) * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value);
					break;
				case 'false,false,true,true,true,true,false':
					var workingAngleA = Math.pow(simplifiedReturnInfo[5], 2) + Math.pow(simplifiedReturnInfo[3], 2) - Math.pow(simplifiedReturnInfo[4], 2);
					workingAngleA = workingAngleA / (2 * simplifiedReturnInfo[5] * simplifiedReturnInfo[3]);
					workingAngleA = toDegrees(Math.acos(workingAngleA));
					returnInfo[0] = Math.round((workingAngleA) * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value);
					var workingAngleC = simplifiedReturnInfo[2];
					returnInfo[1] = Math.round((180 - (workingAngleA + workingAngleC)) * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value);
					break;
				// Law of sine - AAS
				case 'true,true,true,false,true,false,false':
				case 'true,true,false,true,true,false,false':
				case 'true,true,false,false,true,true,false':
				case 'true,true,true,true,true,false,false':
				case 'true,true,true,false,true,true,false':
				case 'true,true,false,false,true,false,false':
					var workingAngleC = 180 - simplifiedReturnInfo[0] - simplifiedReturnInfo[1];
					if (returnInfo[2] != "" && Math.round(returnInfo[2] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value) != Math.round(workingAngleC * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value)) {
						console.log("Measurements do not match up");
						console.log(returnInfo);
						document.getElementById("Error").innerText = "Measurements do not match up";
						return ["", "", "", "", "", ""];
					} else {
						returnInfo[2] = workingAngleC;
					}
					var sineA = Math.sin(toRadians(simplifiedReturnInfo[0]));
					var sineB = Math.sin(toRadians(simplifiedReturnInfo[1]));
					var sineC = Math.sin(toRadians(returnInfo[2]));
					var workingSideAB = sineC * simplifiedReturnInfo[4];
					workingSideAB = workingSideAB / sineA;
					if (returnInfo[3] != "" && Math.round(returnInfo[3] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value) != Math.round(workingSideAB * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value)) {
						console.log("Measurements do not match up");
						console.log(returnInfo);
						document.getElementById("Error").innerText = "Measurements do not match up";
						return ["", "", "", "", "", ""];
					} else {
						returnInfo[3] = workingSideAB;
					}
					var workingSideAC = sineB * simplifiedReturnInfo[4];
					workingSideAC = workingSideAC / sineA;
					if (returnInfo[5] != "" && Math.round(returnInfo[5] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value) != Math.round(workingSideAC * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value)) {
						console.log("Measurements do not match up");
						console.log(returnInfo);
						document.getElementById("Error").innerText = "Measurements do not match up";
						return ["", "", "", "", "", ""];
					} else {
						returnInfo[5] = workingSideAC;
					}
					break;
				case 'true,false,true,true,true,false,false':
				case 'true,false,true,false,true,true,false':
				case 'true,false,true,false,true,false,false':
					var workingAngleB = 180 - simplifiedReturnInfo[0] - simplifiedReturnInfo[2];
					if (returnInfo[1] != "" && Math.round(simplifiedReturnInfo[1] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value) != Math.round(workingAngleB * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value)) {
						console.log("Measurements do not match up");
						console.log(returnInfo);
						document.getElementById("Error").innerText = "Measurements do not match up";
						return ["", "", "", "", "", ""];
					} else {
						returnInfo[1] = workingAngleB;
					}
					var sineA = Math.sin(toRadians(simplifiedReturnInfo[0]));
					var sineB = Math.sin(toRadians(returnInfo[1]));
					var sineC = Math.sin(toRadians(simplifiedReturnInfo[2]));
					var workingSideAB = sineC * simplifiedReturnInfo[4];
					workingSideAB = workingSideAB / sineC;
					if (returnInfo[3] != "" && Math.round(simplifiedReturnInfo[3] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value) != Math.round(workingSideAB * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value)) {
						console.log("Measurements do not match up");
						console.log(returnInfo);
						document.getElementById("Error").innerText = "Measurements do not match up";
						return ["", "", "", "", "", ""];
					} else {
						returnInfo[3] = workingSideAB;
					}
					var workingSideAC = sineB * simplifiedReturnInfo[4];
					workingSideAC = workingSideAC / sineA;
					if (returnInfo[5] != "" && Math.round(simplifiedReturnInfo[5] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value) != Math.round(workingSideAC * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value)) {
						console.log("Measurements do not match up");
						console.log(returnInfo);
						document.getElementById("Error").innerText = "Measurements do not match up";
						return ["", "", "", "", "", ""];
					} else {
						returnInfo[5] = workingSideAC;
					}
					break;
				case 'true,true,true,true,false,false,false':
				case 'false,true,true,true,true,false,false':
				case 'false,true,true,true,false,true,false':
				case 'true,true,true,true,false,true,false':
				case 'false,true,true,true,false,false,false':
					var workingAngleA = 180 - simplifiedReturnInfo[2] - simplifiedReturnInfo[1];
					if (returnInfo[0] != "" && Math.round(simplifiedReturnInfo[0] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value) != Math.round(workingAngleA * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value)) {
						console.log("Measurements do not match up");
						console.log(returnInfo);
						document.getElementById("Error").innerText = "Measurements do not match up";
						return ["", "", "", "", "", ""];
					} else {
						returnInfo[0] = workingAngleA;
					}
					var sineA = Math.sin(toRadians(returnInfo[0]));
					var sineB = Math.sin(toRadians(simplifiedReturnInfo[1]));
					var sineC = Math.sin(toRadians(simplifiedReturnInfo[2]));
					var workingSideAC = sineB * simplifiedReturnInfo[3];
					workingSideAC = workingSideAC / sineC;
					if (returnInfo[5] != "" && Math.round(simplifiedReturnInfo[5] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value) != Math.round(workingSideAC * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value)) {
						console.log("Measurements do not match up");
						console.log(returnInfo);
						document.getElementById("Error").innerText = "Measurements do not match up";
						return ["", "", "", "", "", ""];
					} else {
						returnInfo[5] = workingSideAC;
					}
					var workingSideBC = sineA * simplifiedReturnInfo[3];
					workingSideBC = workingSideBC / sineC;
					if (returnInfo[4] != "" && Math.round(simplifiedReturnInfo[4] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value) != Math.round(workingSideAB * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value)) {
						console.log("Measurements do not match up");
						console.log(returnInfo);
						document.getElementById("Error").innerText = "Measurements do not match up";
						return ["", "", "", "", "", ""];
					} else {
						returnInfo[4] = workingSideBC;
					}
					break;
				case 'true,false,true,true,false,true,false':
				case 'true,false,true,true,false,false,false':
					var workingAngleB = 180 - simplifiedReturnInfo[2] - simplifiedReturnInfo[0];
					if (returnInfo[1] != "" && Math.round(simplifiedReturnInfo[1] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value) != Math.round(workingAngleB * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value)) {
						console.log("Measurements do not match up");
						console.log(returnInfo);
						document.getElementById("Error").innerText = "Measurements do not match up";
						return ["", "", "", "", "", ""];
					} else {
						returnInfo[1] = workingAngleB;
					}
					var sineA = Math.sin(toRadians(simplifiedReturnInfo[0]));
					var sineB = Math.sin(toRadians(returnInfo[1]));
					var sineC = Math.sin(toRadians(simplifiedReturnInfo[2]));
					var workingSideBC = sineA * simplifiedReturnInfo[3];
					workingSideAB = workingSideAB / sineB;
					if (returnInfo[4] != "" && Math.round(simplifiedReturnInfo[4] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value) != Math.round(workingSideAB * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value)) {
						console.log("Measurements do not match up");
						console.log(returnInfo);
						document.getElementById("Error").innerText = "Measurements do not match up";
						return ["", "", "", "", "", ""];
					} else {
						returnInfo[4] = workingSideAB;
					}
					var workingSideAC = sineB * returnInfo[4];
					workingSideAC = workingSideAC / sineA;
					if (returnInfo[5] != "" && Math.round(simplifiedReturnInfo[5] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value) != Math.round(workingSideAC * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value)) {
						console.log("Measurements do not match up");
						console.log(returnInfo);
						document.getElementById("Error").innerText = "Measurements do not match up";
						return ["", "", "", "", "", ""];
					} else {
						returnInfo[5] = workingSideAC;
					}
					break;
				case 'true,true,true,false,false,true,false':
				case 'true,true,false,true,false,true,false':
				case 'true,true,false,false,false,true,false':
					var workingAngleC = 180 - simplifiedReturnInfo[0] - simplifiedReturnInfo[1];
					if (returnInfo[2] != "" && Math.round(simplifiedReturnInfo[2] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value) != Math.round(workingAngleC * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value)) {
						console.log("Measurements do not match up");
						console.log(returnInfo);
						document.getElementById("Error").innerText = "Measurements do not match up";
						return ["", "", "", "", "", ""];
					} else {
						returnInfo[2] = workingAngleC;
					}
					var sineA = Math.sin(toRadians(simplifiedReturnInfo[0]));
					var sineB = Math.sin(toRadians(simplifiedReturnInfo[1]));
					var sineC = Math.sin(toRadians(returnInfo[2]));
					var workingSideBC = sineA * simplifiedReturnInfo[5];
					workingSideBC = workingSideBC / sineB;
					if (returnInfo[3] != "" && Math.round(simplifiedReturnInfo[3] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value) != Math.round(workingSideBC * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value)) {
						console.log("Measurements do not match up");
						console.log(returnInfo);
						document.getElementById("Error").innerText = "Measurements do not match up";
						return ["", "", "", "", "", ""];
					} else {
						returnInfo[3] = workingSideBC;
					}
					var workingSideAB = sineC * returnInfo[5];
					workingSideAB = workingSideAB / sineB;
					if (returnInfo[4] != "" && Math.round(simplifiedReturnInfo[4] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value) != Math.round(workingSideAB * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value)) {
						console.log("Measurements do not match up");
						console.log(returnInfo);
						document.getElementById("Error").innerText = "Measurements do not match up";
						return ["", "", "", "", "", ""];
					} else {
						returnInfo[4] = workingSideAB;
					}
					break;
				case 'false,true,true,false,true,true,false':
				case 'false,true,true,false,false,true,false':
					var workingAngleA = 180 - simplifiedReturnInfo[1] - simplifiedReturnInfo[2];
					if (returnInfo[0] != "" && Math.round(simplifiedReturnInfo[0] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value) != Math.round(workingAngleA * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value)) {
						console.log("Measurements do not match up");
						console.log(returnInfo);
						document.getElementById("Error").innerText = "Measurements do not match up";
						return ["", "", "", "", "", ""];
					} else {
						returnInfo[0] = workingAngleA;
					}
					var sineA = Math.sin(toRadians(returnInfo[0]));
					var sineB = Math.sin(toRadians(simplifiedReturnInfo[1]));
					var sineC = Math.sin(toRadians(simplifiedReturnInfo[2]));
					var workingSideBC = sineA * simplifiedReturnInfo[5];
					workingSideBC = workingSideBC / sineB;
					if (returnInfo[3] != "" && Math.round(simplifiedReturnInfo[3] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value) != Math.round(workingSideBC * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value)) {
						console.log("Measurements do not match up");
						console.log(returnInfo);
						document.getElementById("Error").innerText = "Measurements do not match up";
						return ["", "", "", "", "", ""];
					} else {
						returnInfo[3] = workingSideBC;
					}
					var workingSideAB = sineC * returnInfo[5];
					workingSideAB = workingSideAB / sineB;
					if (returnInfo[4] != "" && Math.round(simplifiedReturnInfo[4] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value) != Math.round(workingSideAB * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value)) {
						console.log("Measurements do not match up");
						console.log(returnInfo);
						document.getElementById("Error").innerText = "Measurements do not match up";
						return ["", "", "", "", "", ""];
					} else {
						returnInfo[4] = workingSideAB;
					}
					break;
				// Law of Sine - ASA
				case 'true,true,false,true,false,false,false':
					var workingAngleC = 180 - simplifiedReturnInfo[0] - simplifiedReturnInfo[1];
					returnInfo[2] = workingAngleC;
					var sineA = Math.sin(toRadians(simplifiedReturnInfo[0]));
					var sineB = Math.sin(toRadians(simplifiedReturnInfo[1]));
					var sineC = Math.sin(toRadians(returnInfo[2]));
					var workingSideAC = sineB * simplifiedReturnInfo[3];
					workingSideAC = workingSideAC / sineC;
					returnInfo[5] = workingSideAC;
					var workingSideBC = sineA * simplifiedReturnInfo[3];
					workingSideBC = workingSideBC / sineC;
					returnInfo[4] = workingSideBC;
					break;
				case 'true,false,true,false,false,true,false':
					var workingAngleB = 180 - simplifiedReturnInfo[0] - simplifiedReturnInfo[2];
					returnInfo[1] = workingAngleB;
					var sineA = Math.sin(toRadians(simplifiedReturnInfo[0]));
					var sineB = Math.sin(toRadians(returnInfo[1]));
					var sineC = Math.sin(toRadians(simplifiedReturnInfo[2]));
					var workingSideBC = sineA * simplifiedReturnInfo[5];
					workingSideBC = workingSideBC / sineB;
					returnInfo[3] = workingSideBC;
					var workingSideAB = sineC * returnInfo[5];
					workingSideAB = workingSideAB / sineB;
					returnInfo[4] = workingSideAB;
					break;
				case 'false,true,true,false,true,false,false':
					var workingAngleA = 180 - simplifiedReturnInfo[1] - simplifiedReturnInfo[2];
					returnInfo[0] = workingAngleA;
					var sineA = Math.sin(toRadians(returnInfo[0]));
					var sineB = Math.sin(toRadians(simplifiedReturnInfo[1]));
					var sineC = Math.sin(toRadians(simplifiedReturnInfo[2]));
					var workingSideAB = sineC * simplifiedReturnInfo[4];
					workingSideAB = workingSideAB / sineC;
					returnInfo[3] = workingSideAB;
					var workingSideAC = sineB * simplifiedReturnInfo[4];
					workingSideAC = workingSideAC / sineA;
					returnInfo[5] = workingSideAC;
					break;
				// Law of sine - SSA (Unfortunately, this works.)
				case 'true,false,false,true,true,false,false':
					var sineA = Math.sin(toRadians(simplifiedReturnInfo[0]));
					var workingAngleC = sineA * simplifiedReturnInfo[3];
					workingAngleC = workingAngleC / simplifiedReturnInfo[4];
					workingAngleC = toDegrees(Math.asin(workingAngleC));
					returnInfo[2] = workingAngleC;
					returnInfo[1] = 180 - simplifiedReturnInfo[0] - returnInfo[2];
					var sineB = Math.sin(toRadians(returnInfo[1]));
					var workingSideAC = sineB * simplifiedReturnInfo[4];
					workingSideAC = workingSideAC / sineA;
					returnInfo[5] = workingSideAC;
					break;
				case 'true,false,false,false,true,true,false':
					var sineA = Math.sin(toRadians(simplifiedReturnInfo[0]));
					var workingAngleB = sineA * simplifiedReturnInfo[5];
					workingAngleB = workingAngleB / simplifiedReturnInfo[4];
					workingAngleB = toDegrees(Math.asin(workingAngleB));
					returnInfo[1] = workingAngleB;
					returnInfo[2] = 180 - simplifiedReturnInfo[0] - returnInfo[1];
					var sineC = Math.sin(toRadians(returnInfo[2]));
					var workingSideAB = sineC * simplifiedReturnInfo[4];
					workingSideAB = workingSideAB / sineA;
					returnInfo[3] = workingSideAB;
					break;
				case 'false,true,false,true,false,true,false':
					var sineB = Math.sin(toRadians(simplifiedReturnInfo[1]));
					var workingAngleC = sineB * simplifiedReturnInfo[3];
					workingAngleC = workingAngleC / simplifiedReturnInfo[5];
					workingAngleC = toDegrees(Math.asin(workingAngleC));
					returnInfo[2] = workingAngleC;
					returnInfo[0] = 180 - simplifiedReturnInfo[1] - returnInfo[2];
					var sineA = Math.sin(toRadians(returnInfo[0]));
					var workingSideBC = sineA * simplifiedReturnInfo[5];
					workingSideBC = workingSideBC / sineB;
					returnInfo[4] = workingSideBC;
					break;
				case 'false,true,false,false,true,true,false':
					var sineB = Math.sin(toRadians(simplifiedReturnInfo[1]));
					var workingAngleA = sineB * simplifiedReturnInfo[4];
					workingAngleA = workingAngleA / simplifiedReturnInfo[5];
					workingAngleA = toDegrees(Math.asin(workingAngleA));
					returnInfo[0] = workingAngleA;
					returnInfo[2] = 180 - simplifiedReturnInfo[1] - returnInfo[0];
					var sineC = Math.sin(toRadians(returnInfo[2]));
					var workingSideAB = sineC * simplifiedReturnInfo[5];
					workingSideAB = workingSideAB / sineB;
					returnInfo[3] = workingSideAB;
					break;
				case 'false,false,true,true,false,true,false':
					var sineC = Math.sin(toRadians(simplifiedReturnInfo[2]));
					var workingAngleB = sineB * simplifiedReturnInfo[5];
					workingAngleB = workingAngleB / simplifiedReturnInfo[3];
					workingAngleB = toDegrees(Math.asin(workingAngleB));
					returnInfo[1] = workingAngleB;
					returnInfo[0] = 180 - returnInfo[1] - simplifiedReturnInfo[2];
					var sineA = Math.sin(toRadians(returnInfo[0]));
					var workingSideBC = sineA * simplifiedReturnInfo[5];
					workingSideBC = workingSideBC / sineB;
					returnInfo[4] = workingSideBC;
					break;
				case 'false,false,true,true,true,false,false':
					var sineC = Math.sin(toRadians(simplifiedReturnInfo[2]));
					var workingAngleA = sineC * simplifiedReturnInfo[4];
					workingAngleA = workingAngleA / simplifiedReturnInfo[3];
					workingAngleA = toDegrees(Math.asin(workingAngleA));
					returnInfo[1] = workingAngleA;
					returnInfo[0] = 180 - returnInfo[1] - simplifiedReturnInfo[2];
					var sineA = Math.sin(toRadians(returnInfo[0]));
					var sineB = Math.sin(toRadians(returnInfo[1]));
					var workingSideBC = sineA * simplifiedReturnInfo[5];
					workingSideBC = workingSideBC / sineB;
					returnInfo[4] = workingSideBC;
					break;
				// Law of Cosine - SAS
				case 'true,false,false,true,false,true,false':
					var cosineA = Math.cos(toRadians(simplifiedReturnInfo[0]));
					var workingSideBC = Math.pow(simplifiedReturnInfo[3], 2) + Math.pow(simplifiedReturnInfo[5], 2);
					workingSideBC -= (2 * simplifiedReturnInfo[3] * simplifiedReturnInfo[5] * cosineA);
					returnInfo[4] = workingSideBC;
					var workingAngleB = (Math.pow(returnInfo[4], 2) + Math.pow(simplifiedReturnInfo[3], 2) - Math.pow(simplifiedReturnInfo[5], 2)) / (2 * returnInfo[4] * simplifiedReturnInfo[3])
					workingAngleB = toDegrees(Math.acos(workingAngleB));
					returnInfo[1] = workingAngleB;
					returnInfo[2] = 180 - simplifiedReturnInfo[0] - returnInfo[1];
					break;
				case 'false,true,false,true,true,false,false':
					var cosineB = Math.cos(toRadians(simplifiedReturnInfo[1]));
					var workingSideAC = Math.pow(simplifiedReturnInfo[3], 2) + Math.pow(simplifiedReturnInfo[4], 2);
					workingSideAC -= (2 * simplifiedReturnInfo[3] * simplifiedReturnInfo[4] * cosineB);
					returnInfo[5] = workingSideAC;
					var workingAngleA = (Math.pow(simplifiedReturnInfo[3], 2) + Math.pow(returnInfo[5], 2) - Math.pow(simplifiedReturnInfo[4], 2)) / (2 * simplifiedReturnInfo[3] * returnInfo[5])
					workingAngleA = toDegrees(Math.acos(workingAngleA));
					returnInfo[0] = workingAngleA;
					returnInfo[2] = 180 - returnInfo[0] - simplifiedReturnInfo[1];
					break;
				case 'false,false,true,false,true,true,false':
					var cosineC = Math.cos(toRadians(simplifiedReturnInfo[2]));
					var workingSideAB = Math.pow(simplifiedReturnInfo[4], 2) + Math.pow(simplifiedReturnInfo[5], 2);
					workingSideAB -= (2 * simplifiedReturnInfo[4] * simplifiedReturnInfo[5] * cosineC);
					returnInfo[3] = workingSideAB;
					var workingAngleA = (Math.pow(returnInfo[3], 2) + Math.pow(simplifiedReturnInfo[5], 2) - Math.pow(simplifiedReturnInfo[4], 2)) / (2 * returnInfo[3] * simplifiedReturnInfo[5])
					workingAngleA = toDegrees(Math.acos(workingAngleA));
					returnInfo[0] = workingAngleA;
					returnInfo[1] = 180 - returnInfo[0] - simplifiedReturnInfo[2];
					break;
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Right Triangles - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				// Pythagorean Theorem - 2 Sides and 3 angles
				case 'true,true,true,true,true,false,true':
					returnInfo[5] = Math.sqrt(Math.pow(simplifiedReturnInfo[3], 2) + Math.pow(simplifiedReturnInfo[4], 2))
					break;
				case 'true,true,true,false,true,true,true':
					returnInfo[3] = Math.sqrt(Math.pow(simplifiedReturnInfo[5], 2) - Math.pow(simplifiedReturnInfo[4], 2));
					break;
				case 'true,true,true,true,false,true,true':
					returnInfo[4] = Math.sqrt(Math.pow(simplifiedReturnInfo[5], 2) - Math.pow(simplifiedReturnInfo[3], 2));
					break;
				// 2 angles missing - Sine
				case 'false,true,false,true,true,true,true':
					var workingAngleA = simplifiedReturnInfo[4] / simplifiedReturnInfo[5];
					workingAngleA = toDegrees(Math.asin(workingAngleA));
					returnInfo[0] = workingAngleA;
					returnInfo[2] = 90 - returnInfo[0];
					break;
				// 2 Sides missing - Right triangle
				case 'true,true,true,true,false,false,true':
					var workingSideAC = simplifiedReturnInfo[3] / Math.sin(toRadians(returnInfo[2]));
					returnInfo[5] = workingSideAC;
					var workingSideBC = returnInfo[5] * Math.sin(toRadians(returnInfo[0]));
					returnInfo[4] = workingSideBC;
					break;
				case 'true,true,true,false,true,false,true':
					var workingSideAC = simplifiedReturnInfo[4] / Math.sin(toRadians(returnInfo[0]));
					returnInfo[5] = workingSideAC;
					var workingSideAB = returnInfo[5] * Math.sin(toRadians(returnInfo[2]));
					returnInfo[3] = workingSideBC;
					break;
				case 'true,true,true,false,false,true,true':
					var workingSideBC = simplifiedReturnInfo[5] * Math.sin(toRadians(returnInfo[0]));
					returnInfo[4] = workingSideAC;
					var workingSideAB = simplifiedReturnInfo[5] * Math.sin(toRadians(returnInfo[2]));
					returnInfo[3] = workingSideBC;
					break;
				// 2 sides and 2 angles - Triangle 180 and Pythagorean Therorem
				case 'true,true,false,true,true,false,true':
					var workingAngleC = 90 - simplifiedReturnInfo[0];
					returnInfo[2] = workingAngleC;
					var workingSideAC = Math.sqrt(Math.pow(simplifiedReturnInfo[3], 2) + Math.pow(simplifiedReturnInfo[4], 2));
					returnInfo[5] = workingSideAC;
					break;
				case 'true,true,false,false,true,true,true':
					var workingAngleC = 90 - simplifiedReturnInfo[0];
					returnInfo[2] = workingAngleC;
					var workingSideAB = Math.sqrt(Math.pow(simplifiedReturnInfo[5], 2) - Math.pow(simplifiedReturnInfo[4], 2));
					returnInfo[3] = workingSideAC;
					break;
				case 'true,true,false,true,false,true,true':
					var workingAngleC = 90 - simplifiedReturnInfo[0];
					returnInfo[2] = workingAngleC;
					var workingSideBC = Math.sqrt(Math.pow(simplifiedReturnInfo[5], 2) - Math.pow(simplifiedReturnInfo[3], 2));
					returnInfo[4] = workingSideBC;
					break;
				case 'false,true,true,true,true,false,true':
					var workingAngleA = 90 - simplifiedReturnInfo[2];
					returnInfo[0] = workingAngleA;
					var workingSideAC = Math.sqrt(Math.pow(simplifiedReturnInfo[3], 2) + Math.pow(simplifiedReturnInfo[4], 2));
					returnInfo[5] = workingSideAC;
					break;
				case 'false,true,true,false,true,true,true':
					var workingAngleA = 90 - simplifiedReturnInfo[2];
					returnInfo[0] = workingAngleA;
					var workingSideAB = Math.sqrt(Math.pow(simplifiedReturnInfo[5], 2) - Math.pow(simplifiedReturnInfo[4], 2));
					returnInfo[3] = workingSideAC;
					break;
				case 'false,true,true,true,false,true,true':
					var workingAngleA = 90 - simplifiedReturnInfo[2];
					returnInfo[0] = workingAngleA;
					var workingSideBC = Math.sqrt(Math.pow(simplifiedReturnInfo[5], 2) - Math.pow(simplifiedReturnInfo[3], 2));
					returnInfo[4] = workingSideBC;
					break;
				// 2 Angles and 1 side - Triangle 180 and SOHCAHTOA
				case 'true,true,false,true,false,false,true':
					returnInfo[2] = 90 - simplifiedReturnInfo[0];
					var workingSideBC = simplifiedReturnInfo[3] * Math.tan(toRadians(returnInfo[0]));
					returnInfo[4] = workingSideBC;
					var workingSideAC = Math.sqrt(Math.pow(simplifiedReturnInfo[3], 2) + Math.pow(returnInfo[4], 2));
					returnInfo[5] = workingSideAC;
					break;
				case 'true,true,false,false,true,false,true':
					returnInfo[2] = 90 - simplifiedReturnInfo[0];
					var workingSideAC = simplifiedReturnInfo[4] / Math.sin(toRadians(returnInfo[0]));
					returnInfo[5] = workingSideAC;
					var workingSideAB = Math.sqrt(Math.pow(returnInfo[5], 2) - Math.pow(simplifiedReturnInfo[4], 2));
					returnInfo[3] = workingSideAB;
					break;
				case 'true,true,false,false,false,true,true':
					returnInfo[2] = 90 - simplifiedReturnInfo[0];
					var workingSideAB = Math.sin(toRadians(returnInfo[2])) * simplifiedReturnInfo[5];
					returnInfo[3] = workingSideAB;
					var workingSideBC = Math.sqrt(Math.pow(simplifiedReturnInfo[5], 2) - Math.pow(returnInfo[3], 2));
					returnInfo[4] = workingSideBC;
					break;
				case 'false,true,true,true,false,false,true':
					returnInfo[0] = 90 - simplifiedReturnInfo[2];
					var workingSideAC = simplifiedReturnInfo[3] / Math.sin(toRadians(simplifiedReturnInfo[2]));
					returnInfo[5] = workingSideAC;
					var workingSideBC = Math.sqrt(Math.pow(returnInfo[5], 2) - Math.pow(simplifiedReturnInfo[3], 2));
					returnInfo[4] = workingSideBC;
					break;
				case 'false,true,true,false,true,false,true':
					returnInfo[0] = 90 - simplifiedReturnInfo[2];
					var workingSideAC = simplifiedReturnInfo[4] / Math.sin(toRadians(returnInfo[0]));
					returnInfo[5] = workingSideAC;
					var workingSideAB = Math.sqrt(Math.pow(returnInfo[5], 2) - Math.pow(simplifiedReturnInfo[4], 2));
					returnInfo[3] = workingSideAB;
					break;
				case 'false,true,true,false,false,true,true':
					returnInfo[0] = 90 - simplifiedReturnInfo[2];
					var workingSideAB = Math.sin(toRadians(simplifiedReturnInfo[2])) * simplifiedReturnInfo[5];
					returnInfo[3] = workingSideAB;
					var workingSideBC = Math.sqrt(Math.pow(simplifiedReturnInfo[5], 2) - Math.pow(returnInfo[3], 2));
					returnInfo[4] = workingSideBC;
					break;
				// 2 sides and no angles
				case 'false,true,false,true,true,false,true':
					var workingSideAC = Math.sqrt(Math.pow(simplifiedReturnInfo[3], 2) + Math.pow(simplifiedReturnInfo[4], 2));
					returnInfo[5] = workingSideAC;
					var workingAngleA = simplifiedReturnInfo[4] / returnInfo[5];
					workingAngleA = toDegrees(Math.asin(workingAngleA));
					returnInfo[0] = workingAngleA;
					var workingAngleC = simplifiedReturnInfo[3] / returnInfo[5];
					workingAngleC = toDegrees(Math.asin(workingAngleC));
					returnInfo[2] = workingAngleC;
					break;
				case 'false,true,false,false,true,true,true':
					var workingSideAB = Math.sqrt(Math.pow(simplifiedReturnInfo[5], 2) - Math.pow(simplifiedReturnInfo[4], 2));
					returnInfo[3] = workingSideAC;
					var workingAngleA = simplifiedReturnInfo[4] / simplifiedReturnInfo[5];
					workingAngleA = toDegrees(Math.asin(workingAngleA));
					returnInfo[0] = workingAngleA;
					var workingAngleC = returnInfo[3] / simplifiedReturnInfo[5];
					workingAngleC = toDegrees(Math.asin(workingAngleC));
					returnInfo[2] = workingAngleC;
					break;
				case 'false,true,false,true,false,true,true':
					var workingSideBC = Math.sqrt(Math.pow(simplifiedReturnInfo[5], 2) - Math.pow(simplifiedReturnInfo[3], 2));
					returnInfo[4] = workingSideAC;
					var workingAngleA = returnInfo[4] / simplifiedReturnInfo[5];
					workingAngleA = toDegrees(Math.asin(workingAngleA));
					returnInfo[0] = workingAngleA;
					var workingAngleC = simplifiedReturnInfo[3] / simplifiedReturnInfo[5];
					workingAngleC = toDegrees(Math.asin(workingAngleC));
					returnInfo[2] = workingAngleC;
					break;
				default:
					console.log("Not enough info");
					document.getElementById("Error").innerText = "Not enough information";
					return ["", "", "", "", "", ""];
			}
			for (var x = 0; x < returnInfo.length; x++) {
				if (boolValues[x] == true) {
					returnInfo[x] = simplifiedReturnInfo[x]
				}
				if (is_int(Math.round(returnInfo[x] * returnInfo[x] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value)) == true) {
					returnInfo[x] = radical(Math.round(returnInfo[x] * returnInfo[x]));
				} else {
					returnInfo[x] = Math.round(returnInfo[x] * Math.pow(10, document.getElementById("Rounding").value)) / Math.pow(10, document.getElementById("Rounding").value);
				}
			}
			if (Number(returnInfo[0]) + Number(returnInfo[1]) + Number(returnInfo[2]) != 180) {
				console.log("Angles do not match up");
				console.log("Measurements:");
				console.log(returnInfo);
				document.getElementById("Error").innerText = "Angles do not match up";
				return ["", "", "", "", "", ""];
			}
			return returnInfo;
		}
		function radical(equation) {
			if (is_int(Math.sqrt(equation)) == true) {
				return Math.sqrt(equation);
			} else if (equation < 0) {
				var answer = simplify(-equation);
				if (answer[0] != 1 && answer[1] != 1) {
					answer = answer[0] + "√" + answer[1];
				} else if (answer[0] == 1 && answer[1] != 1) {
					answer = "√" + answer[1];
				} else {
					answer = answer[0];
				}
				answer += "<i>i</i>";
			} else {
				var answer = simplify(equation);
				if (answer[0] != 1 && answer[1] != 1) {
					answer = answer[0] + "√" + answer[1];
				} else if (answer[0] == 1 && answer[1] != 1) {
					answer = "√" + answer[1];
				} else {
					answer = answer[0];
				}
			}
			return answer;
		}
		function simplify(equation) {
			var possibleSquares = [];
			for (var x = Math.sqrt(Number(equation)).toFixed(0); x > 1; x--) {
				possibleSquares.push(x * x);
			}
			var coefficient = 0;
			for (x = 0; x < possibleSquares.length; x++) {
				if (is_int(Number(equation) / possibleSquares[x]) === true) {
					var radicalLength = equation.toString().length;
					var roof = "_";
					for (var y = 0; y < radicalLength; y++) {
						roof += "_";
					}
					equation = Number(equation) / possibleSquares[x];
					coefficient += Math.sqrt(possibleSquares[x]);
				}
			}
			if (coefficient == 0) {
				coefficient = 1;
			}
			return [coefficient, equation];
		}
		function is_int(mixed_var) {
			return mixed_var === +mixed_var && !(mixed_var % 1);
		}
	</script>
	<noscript>Your browser does not support JavaScript!</noscript>
	<H5 style="position: fixed; bottom: 0px; right: 25px; color: #000000" id="mine">
	Copyright Josh Lawson
	</H5>
	<div style="position: fixed; bottom: 0px; left: 0px; color: #000000">
		<a href="https://josh-d-l.github.io/Math-Machines/" style="font-size: 200%;">Home Page</a>
 	</div>
</BODY>

</HTML>
